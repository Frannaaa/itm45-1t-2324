# Francine Y. de Asis, 221927
# March 7, 2024

# I/we certify that this submission complies with the DISCS Academic Integrity
# Policy.

# If I/we have discussed my/our Python language code with anyone other than
# my/our instructor(s), my/our groupmate(s), the teaching assistant(s),
# the extent of each discussion has been clearly noted along with a proper
# citation in the comments of my/our program.

# If any Python language code or documentation used in my/our program
# was obtained from another source, either modified or unmodified, such as a
# textbook, website, or another individual, the extent of its use has been
# clearly noted along with a proper citation in the comments of my/our program.

################################################################################

# cite your sources here, if any

################################################################################
# Francine Y. de Asis, 221927
# March 7, 2024 

# I/we certify that this submission complies with the DISCS Academic Integrity
# Policy.

# If I/we have discussed my/our Python language code with anyone other than
# my/our instructor(s), my/our groupmate(s), the teaching assistant(s),
# the extent of each discussion has been clearly noted along with a proper
# citation in the comments of my/our program.

# If any Python language code or documentation used in my/our program
# was obtained from another source, either modified or unmodified, such as a
# textbook, website, or another individual, the extent of its use has been
# clearly noted along with a proper citation in the comments of my/our program.

################################################################################

# cite your sources here, if any

################################################################################
#additional features for uniqueness: supports phrases, two or more words/phrase, hints if 3 mistakes straight, for random list they can choose easy (4 letters max), medium (4-6 letters), or hard (7-any number of letters)
#avoid using index, .choice, chr, sum, enumerate, .replace, join , next, all  format , .join(), .isdigit(), .lstrip(), all(), enumerate, .isalpha(), and of .values . sum, any, max, next. import randomimport random
#to fix: hangman display figure, remove ord 

'''
questions:
-can allowed phrases be an orig feature 
- incorporating hangman stage but also the any number of guesses, is it possible it just restarts?
 - in and not in, as a compa opera not allowed

'''

import random
from typing import List

# Global variables Preset words list, all in uppercase for consistency
WORDS = [
    "DIE", "TOP", "CRY", "MIKU", "LINK", "CODE", "SKYRIM", "MALENIA", "STARDUST",
    "SUPERCALIFRAGILISTICEXPIALIDOCIOUS", "PNEUMONOULTRAMICROSCOPICSILICOVOLCANOCONIOSIS",
    "WHAT IF I CRY AND EXPLODE INTO STARDUST", "LIFE IS BEAUTIFUL EVEN IF YOU DO BREAKDOWN OVER THIS CODE",
    "MOM PICK ME UP I AM SCARED"
]

# Utlityt Functions Define uppercase and lowercase alphabets for letter conversion
alphabet_upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
alphabet_lower = "abcdefghijklmnopqrstuvwxyz"
alphabet = alphabet_upper  # This is assuming you're using uppercase letters for unused letters display

# Function to convert a lowercase character to uppercase
def char_to_upper(char):
    for i in range(len(alphabet_lower)):
        if char == alphabet_lower[i]:
            return alphabet_upper[i]
    return char

# Function to convert an entire string to uppercase
def input_to_upper(input_string):
    upper_string = ""
    for char in input_string:
        upper_string += char_to_upper(char)
    return upper_string

# Function to check if a letter is in a string
def is_letter_in_string(letter, string):
    for char in string:
        if char == letter:
            return True
    return False

def showStickman(cur_guesses, max_guesses):
    # assume cur_guesses <= max_guesses <= 26
    # size 1 - small, size 2 - medium, size 3 = big stickman
    size, height, width, mx_sticks = 1, 6, 8, 6
    if 6 < max_guesses and max_guesses <= 14:
        size, height, width, mx_sticks = 2, 8, 12, 14
    elif 14 < max_guesses:
        size, height, width, mx_sticks = 3, 11, 19, 26
    
    sticks = mx_sticks - (max_guesses - cur_guesses)
    stickman = [[" " for j in range(width)] for i in range(height)]
    head_x = width-2 - 3*(size-1)
    # build the pole
    for i in range(head_x+1):
        stickman[0][i] = "-"
    for i in range(1, height):
        stickman[i][0] = "|"
    stickman[1][head_x] = "|"
    
    # head and neck
    if sticks >= 1:
        stickman[2][head_x] = 'O'
        sticks -= 1
    if sticks >= 1:
        stickman[3][head_x] = '|'
        sticks -= 1

    # limbs
    limbs = [sticks//4 for i in range(4)]
    for i in range(sticks%4):
        limbs[i] += 1
    
    # left arm
    for i in range(limbs[0]):
        stickman[3][head_x-1-i] = '-'
    
    # right arm
    for i in range(limbs[1]):
        stickman[3][head_x+1+i] = '-'
    
    # left foot
    for i in range(limbs[2]):
        stickman[4+i][head_x-1-i] = '/'
    
    # right foot
    for i in range(limbs[3]):
        stickman[4+i][head_x+1+i] = '\\'

    for row in stickman:
        print(*row, sep="")
        
# Function to get the difficulty level from the user
def get_difficulty():
    difficulty = input_to_upper(input("Choose difficulty (easy/medium/hard/extreme): "))
    while difficulty != "EASY" and difficulty != "MEDIUM" and difficulty != "HARD" and difficulty != "EXTREME":
        print("Please choose a valid difficulty.")
        difficulty = input_to_upper(input("Choose difficulty (easy/medium/hard/extreme): "))
    return difficulty

def count_letters(word):
    letter_count = 0
    for char in word:
        if char != " ":  # Skip spaces
            letter_count += 1
    return letter_count

def filter_words_by_difficulty(words, difficulty):
    def has_space(word):
        for char in word:
            if char == ' ':  # Check for space without using 'in' or 'notin'
                return True
        return False

    if difficulty == "EASY":
        return [word for word in words if len(word) <= 4]
    elif difficulty == "MEDIUM":
        return [word for word in words if 5 <= len(word) <= 6]
    elif difficulty == "HARD":
        # HARD: Long words without spaces, manually check for space
        return [word for word in words if len(word) > 9 and not has_space(word)]
    elif difficulty == "EXTREME":
        # EXTREME: Phrases or words with spaces, manually check for space
        return [word for word in words if has_space(word)]
    return []  # Return an empty list as a fallback

# Adjust get_word_choice to use filter_words_by_difficulty after getting difficulty

# Function to set the number of guesses allowed
def set_number_of_guesses():
    num_guesses = input("Please enter the number of guesses allowed: ")
    is_valid = True
    for char in num_guesses:
        if not ('0' <= char <= '9'):
            is_valid = False
            break
    if is_valid and num_guesses:
        return int(num_guesses)
    else:
        print("Invalid input. Defaulting to 6 guesses.")
        return 6

# Function to display the current status of the game
def display_status(word, guessed_letters, tries):
    print("\nGuess the word, " + str(tries) + " guess(es) left: ", end="")
    for letter in word:
        if letter == " " or is_letter_present(letter, guessed_letters):
            print(letter, end="")
        else:
            print("-", end="")
    print()  # For newline after the word

    # Display unused letters
    print("Unused letters: ", end="")
    for letter in alphabet_upper:
        if not is_letter_present(letter, guessed_letters):
            print(letter, end="")
    print()  # For newline after unused letters

def is_letter_present(letter, string):
    for char in string:
        if char == letter:
            return True
    return False

def validate_choice(choice, valid_options):
    for option in valid_options:
        if choice == option:
            return True
    return False

def get_word_choice():
    valid_responses = ["YES", "NO"]
    choice = input_to_upper(input("Would you like the program to choose a random word? (Yes/No): "))
    
    while not validate_choice(choice, valid_responses):
        print("Invalid choice. Please enter 'Yes' or 'No'.")
        choice = input_to_upper(input("Would you like the program to choose a random word? (Yes/No): "))
    
    if choice == "NO":
        valid_word = False
        while not valid_word:
            word = input_to_upper(input("Enter the word to be guessed by your opponent: "))
            valid_word = True
            for char in word:
                if char != " " and not is_letter_in_string(char, alphabet_upper):
                    valid_word = False
                    print("The word should only contain letters and spaces. Please try again.")
                    break
        return word
    else:
        difficulty = get_difficulty()
        filtered_words = filter_words_by_difficulty(WORDS, difficulty)
        if not filtered_words:
            print("No words available for this difficulty. Please choose a different difficulty.")
            return get_word_choice()  # Recursively call to ensure a valid word is chosen
        random_index = int(random.random() * len(filtered_words))
        return filtered_words[random_index]

def play_game(word, max_tries):
    guessed_letters: List[str] = []
    tries_left = max_tries
    mistakes = 0

    while tries_left > 0:
        display_status(word, guessed_letters, tries_left)
        
        cur_guesses = max_tries - tries_left
        showStickman(cur_guesses, max_tries)
        
        guess = input("Your guess: ")
        guess = char_to_upper(guess)  # Convert guess to uppercase
        
        # Check if guess is valid (single uppercase letter)
        valid_guess = False
        for letter in alphabet_upper:
            if guess == letter:
                valid_guess = True
                break
        
        if not valid_guess or len(guess) != 1:
            print("Invalid input. Please enter a single letter.")
            continue
        
        already_guessed = False
        for guessed in guessed_letters:
            if guess == guessed:
                already_guessed = True
                break
        
        if not already_guessed:
            guessed_letters.append(guess)
            
            guess_in_word = False
            for char in word:
                if guess == char:
                    guess_in_word = True
                    break
            
            if not guess_in_word:
                tries_left -= 1
                mistakes += 1
                if mistakes == 3:
                    print("Hint: Try focusing on common vowels and consonants.")
                    mistakes = 0
            else:
                mistakes = 0
        else:
            print("You have already used that letter.")
        
        all_guessed = True
        for letter in word:
            if letter != " ":
                letter_found = False
                for guessed_letter in guessed_letters:
                    if letter == guessed_letter:
                        letter_found = True
                        break
                if not letter_found:
                    all_guessed = False
                    break
        
        if all_guessed:
            print("CONGRATULATIONS! YOU WIN!")
            return
    
    print("SORRY YOU GOT HANGED! The word was:", word)
    showStickman(max_tries, max_tries)

def main(word=None, max_tries=None):
    if not word or not max_tries:  # If no word or max_tries provided, initialize game
        print("LET'S PLAY HANGMAN!\n")
        word = get_word_choice() if not word else word
        max_tries = set_number_of_guesses() if not max_tries else max_tries
    
    play_game(word, max_tries)

    # Ask to play again with the same word
    play_again = input_to_upper(input("Play again with the same word? (Yes/No): "))
    while not validate_choice(play_again, ["YES", "NO"]):
        print("Please enter a valid option (Yes/No).")
        play_again = input_to_upper(input("Play again with the same word? (Yes/No): "))

    if play_again == "YES":
        main(word, max_tries)  # Replay with the same word and max_tries
    else:  # If not replaying with the same word, ask to start a new game
        start_new_game = input_to_upper(input("Start a new game? (Yes/No): "))
        while not validate_choice(start_new_game, ["YES", "NO"]):
            print("Please enter a valid option.")
            start_new_game = input_to_upper(input("Start a new game? (Yes/No): "))
            
        if start_new_game == "YES":
            main()  # Start a completely new game
        elif start_new_game == "NO":
            print("Thank you for playing. Goodbye!")
            return  # Exit the game

# Ensure entry point starts with no word or max_tries set
if __name__ == "__main__":
    main()
