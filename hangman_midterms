# Francine Y. de Asis, 221927
# March 7, 2024

# I/we certify that this submission complies with the DISCS Academic Integrity
# Policy.

# If I/we have discussed my/our Python language code with anyone other than
# my/our instructor(s), my/our groupmate(s), the teaching assistant(s),
# the extent of each discussion has been clearly noted along with a proper
# citation in the comments of my/our program.

# If any Python language code or documentation used in my/our program
# was obtained from another source, either modified or unmodified, such as a
# textbook, website, or another individual, the extent of its use has been
# clearly noted along with a proper citation in the comments of my/our program.

################################################################################

# cite your sources here, if any

################################################################################
# Francine Y. de Asis, 221927
# March 7, 2024 

# I/we certify that this submission complies with the DISCS Academic Integrity
# Policy.

# If I/we have discussed my/our Python language code with anyone other than
# my/our instructor(s), my/our groupmate(s), the teaching assistant(s),
# the extent of each discussion has been clearly noted along with a proper
# citation in the comments of my/our program.

# If any Python language code or documentation used in my/our program
# was obtained from another source, either modified or unmodified, such as a
# textbook, website, or another individual, the extent of its use has been
# clearly noted along with a proper citation in the comments of my/our program.

################################################################################

# cite your sources here, if any

################################################################################
#additional features for uniqueness: supports phrases, two or more words/phrase, hints if 3 mistakes straight, for random list they can choose easy (4 letters max), medium (4-6 letters), or hard (7-any number of letters)
#avoid using index, .choice, chr, sum, enumerate, .replace, join , next, all  format , .join(), .isdigit(), .lstrip(), all(), enumerate, .isalpha(), and of .values . sum, any, max, next. import randomimport random
#to fix: hangman display figure, remove ord 

'''
questions:
-can allowed phrases be an orig feature 
- incorporating hangman stage but also the any number of guesses, is it possible it just restarts?
 - in and not in, as a compa opera not allowed

'''

import random

# Global variables Preset words list, all in uppercase for consistency
WORDS = [
    "DIE", "TOP", "CRY", "MIKU", "LINK", "CODE", "SKYRIM", "MALENIA", "STARDUST",
    "SUPERCALIFRAGILISTICEXPIALIDOCIOUS", "PNEUMONOULTRAMICROSCOPICSILICOVOLCANOCONIOSIS",
    "WHAT IF I CRY AND EXPLODE INTO STARDUST", "LIFE IS BEAUTIFUL EVEN IF YOU DO BREAKDOWN OVER THIS CODE",
    "MOM PICK ME UP I AM SCARED"
]

# Utlityt Functions Define uppercase and lowercase alphabets for letter conversion
alphabet_upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
alphabet_lower = "abcdefghijklmnopqrstuvwxyz"
alphabet = alphabet_upper  # This is assuming you're using uppercase letters for unused letters display

# Function to convert a lowercase character to uppercase
def char_to_upper(char):
    for i in range(len(alphabet_lower)):
        if char == alphabet_lower[i]:
            return alphabet_upper[i]
    return char

# Function to convert an entire string to uppercase
def input_to_upper(input_string):
    upper_string = ""
    for char in input_string:
        upper_string += char_to_upper(char)
    return upper_string

# Function to check if a letter is in a string
def is_letter_in_string(letter, string):
    for char in string:
        if char == letter:
            return True
    return False

def generate_hangman_stages(max_tries):
    stages = [""] * (max_tries + 1)  # Create a list with placeholders
    for i in range(1, max_tries + 1):
        stage = "\n" * (max_tries - i)  # Create empty lines
        if i >= 1:
            stage += " O\n"  # Head
        if i >= 2:
            stage += " |"  # Body
        if i >= 3:
            stage += " /"  # One leg
        if i >= 4:
            stage = stage[:-1] + "/\\"  # Both legs
        stages[i] = stage
    return stages

def display_hangman(tries_left, stages):
    print(stages[tries_left])
        
# Function to get the word choice from the user,
def get_word_choice():
    valid_responses = ["YES", "NO"]
    choice = input_to_upper(input("Would you like the program to choose a random word? (Yes/No): "))
    while not validate_choice(choice, valid_responses):
        print("Invalid choice. Please enter 'Yes' or 'No'.")
        choice = input_to_upper(input("Would you like the program to choose a random word? (Yes/No): "))
    
    if choice == "NO":
        word = input_to_upper(input("Enter the word to be guessed by your opponent: "))
        return word  # Directly return the word input by the user.
    else:
        difficulty = get_difficulty()
        filtered_words = filter_words_by_difficulty(WORDS, difficulty)  # Filter words based on difficulty
        if not filtered_words:  # Check if the filtered list is empty
            print("No words available for this difficulty. Please choose a different difficulty.")
            return get_word_choice()  # Recursively call itself to get a valid word choice
        random_index = int(random.random() * len(filtered_words))  # Calculate random index without using random.choice or randint
        return filtered_words[random_index]  # Return a word at the calculated random index

# Function to get the difficulty level from the user
def get_difficulty():
    difficulty = input_to_upper(input("Choose difficulty (easy/medium/hard/extreme): "))
    while difficulty != "EASY" and difficulty != "MEDIUM" and difficulty != "HARD" and difficulty != "EXTREME":
        print("Please choose a valid difficulty.")
        difficulty = input_to_upper(input("Choose difficulty (easy/medium/hard/extreme): "))
    return difficulty

def count_letters(word):
    letter_count = 0
    for char in word:
        if char != " ":  # Skip spaces
            letter_count += 1
    return letter_count

def filter_words_by_difficulty(words, difficulty):
    if difficulty == "EASY":
        return [word for word in words if len(word) <= 4]
    elif difficulty == "MEDIUM":
        return [word for word in words if 5 <= len(word) <= 6]
    elif difficulty == "HARD":
        # HARD: Long words without spaces
        return [word for word in words if len(word) > 9 and " " not in word]
    elif difficulty == "EXTREME":
        # EXTREME: Phrases or words with spaces
        return [word for word in words if " " in word]
    return []  # Return an empty list as a fallback

# Adjust get_word_choice to use filter_words_by_difficulty after getting difficulty

# Function to set the number of guesses allowed
def set_number_of_guesses():
    num_guesses = input("Please enter the number of guesses allowed: ")
    is_valid = True
    for char in num_guesses:
        if not ('0' <= char <= '9'):
            is_valid = False
            break
    if is_valid and num_guesses:
        return int(num_guesses)
    else:
        print("Invalid input. Defaulting to 6 guesses.")
        return 6

# Function to display the current status of the game
def display_status(word, guessed_letters, tries):
    print("\nGuess the word, " + str(tries) + " guess(es) left: ", end="")
    for letter in word:
        if letter == " " or is_letter_present(letter, guessed_letters):
            print(letter, end="")
        else:
            print("-", end="")
    print()  # For newline after the word

    # Display unused letters
    print("Unused letters: ", end="")
    for letter in alphabet_upper:
        if not is_letter_present(letter, guessed_letters):
            print(letter, end="")
    print()  # For newline after unused letters

def is_letter_present(letter, string):
    for char in string:
        if char == letter:
            return True
    return False

def input_to_upper(input_string):
    upper_string = ""
    lowercase_letters = list("abcdefghijklmnopqrstuvwxyz")
    uppercase_letters = list("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
    
    for char in input_string:
        if 'a' <= char <= 'z':
            index = 0
            while char != lowercase_letters[index]:
                index += 1
            upper_string += uppercase_letters[index]
        else:
            upper_string += char
    return upper_string


def validate_choice(choice, valid_options):
    for option in valid_options:
        if choice == option:
            return True
    return False

def get_word_choice():
    valid_responses = ["YES", "NO"]
    choice = input_to_upper(input("Would you like the program to choose a random word? (Yes/No): "))
    while not validate_choice(choice, valid_responses):
        print("Invalid choice. Please enter 'Yes' or 'No'.")
        choice = input_to_upper(input("Would you like the program to choose a random word? (Yes/No): "))

    if choice == "NO":
        word = input_to_upper(input("Enter the word to be guessed by your opponent: "))
        return word
    else:
        difficulty = get_difficulty()
        filtered_words = filter_words_by_difficulty(WORDS, difficulty)
        if not filtered_words:
            print("No words available for this difficulty. Please choose a different difficulty.")
            return get_word_choice()  # Recursively call to ensure a valid word is chosen
        random_index = int(random.random() * len(filtered_words))
        return filtered_words[random_index]

def play_game(word, max_tries):
    guessed_letters = ""
    tries_left = max_tries
    mistakes = 0
    hangman_stages = generate_hangman_stages(max_tries)

    while tries_left > 0:
        display_status(word, guessed_letters, tries_left)
        
        # Display hangman for the current stage
        display_hangman(tries_left, hangman_stages)
        
        guess = input("Your guess: ").upper()
        
        if len(guess) != 1 or not guess.isalpha():
            print("Invalid input. Please enter a single letter.")
            continue
        
        if guess not in guessed_letters:
            guessed_letters += guess
            if guess not in word:
                tries_left -= 1
                mistakes += 1
                if mistakes == 3:
                    print("Hint: Try focusing on common vowels and consonants.")
                    mistakes = 0
            else:
                mistakes = 0
        else:
            print("You have already used that letter.")
        
        # Check if all letters have been guessed
        all_guessed = True
        for letter in word:
            if letter != " " and letter not in guessed_letters:
                all_guessed = False
                break
        
        if all_guessed:
            print("CONGRATULATIONS! YOU WIN!")
            return
    
    print("SORRY YOU GOT HANGED! The word was:", word)

# Main function to start the game
def main():
    print("LET'S PLAY HANGMAN!\n")
    word = get_word_choice()
    max_tries = set_number_of_guesses()
    play_game(word, max_tries)

    play_again = input_to_upper(input("Play again with the same word? (Yes/No): "))
    while not validate_choice(play_again, ["YES", "NO"]):
        print("Please enter a valid option (Yes/No).")
        play_again = input_to_upper(input("Play again with the same word? (Yes/No): "))

    if play_again == "YES":
        main()
    elif play_again == "NO":
        start_new_game = input_to_upper(input("Start a new game? (Yes/No): "))
        while not validate_choice(start_new_game, ["YES", "NO"]):
            print("Please enter a valid option.")
            start_new_game = input_to_upper(input("Start a new game? (Yes/No): "))
            
        if start_new_game == "YES":
            main()
        elif start_new_game == "NO":
            return
        else:
            print("Invalid input. Exiting the game.")

# Entry point of the program
if __name__ == "__main__":
    main()
