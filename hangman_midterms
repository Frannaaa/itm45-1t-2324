# Francine Y. de Asis, 221927
# March 7, 2024

# I/we certify that this submission complies with the DISCS Academic Integrity
# Policy.

# If I/we have discussed my/our Python language code with anyone other than
# my/our instructor(s), my/our groupmate(s), the teaching assistant(s),
# the extent of each discussion has been clearly noted along with a proper
# citation in the comments of my/our program.

# If any Python language code or documentation used in my/our program
# was obtained from another source, either modified or unmodified, such as a
# textbook, website, or another individual, the extent of its use has been
# clearly noted along with a proper citation in the comments of my/our program.

################################################################################

# cite your sources here, if any

################################################################################
# Francine Y. de Asis, 221927
# March 7, 2024 

# I/we certify that this submission complies with the DISCS Academic Integrity
# Policy.

# If I/we have discussed my/our Python language code with anyone other than
# my/our instructor(s), my/our groupmate(s), the teaching assistant(s),
# the extent of each discussion has been clearly noted along with a proper
# citation in the comments of my/our program.

# If any Python language code or documentation used in my/our program
# was obtained from another source, either modified or unmodified, such as a
# textbook, website, or another individual, the extent of its use has been
# clearly noted along with a proper citation in the comments of my/our program.

################################################################################

# cite your sources here, if any

################################################################################
#additional features for uniqueness: supports phrases, two or more words/phrase, hints if 3 mistakes straight, for random list they can choose easy (4 letters max), medium (4-6 letters), or hard (7-any number of letters)
#avoid using index, .choice, chr, sum, enumerate, .replace, join , next, all  format , .join(), .isdigit(), .lstrip(), all(), enumerate, .isalpha(), and of .values . sum, any, max, next. import randomimport random
#to fix: hangman display figure, remove ord 

'''
questions:
-can allowed phrases be an orig feature 
- incorporating hangman stage but also the any number of guesses, is it possible it just restarts?
 - in and not in, as a compa opera not allowed

'''

import random

# Global variables Preset words list, all in uppercase for consistency
WORDS = [
    "DIE", "TOP", "CRY", "MIKU", "LINK", "CODE", "SKYRIM", "MALENIA", "STARDUST",
    "SUPERCALIFRAGILISTICEXPIALIDOCIOUS", "PNEUMONOULTRAMICROSCOPICSILICOVOLCANOCONIOSIS",
    "WHAT IF I CRY AND EXPLODE INTO STARDUST", "LIFE IS BEAUTIFUL EVEN IF YOU DO BREAKDOWN OVER THIS CODE",
    "MOM PICK ME UP I AM SCARED"
]

# Utlityt Functions Define uppercase and lowercase alphabets for letter conversion
alphabet_upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
alphabet_lower = "abcdefghijklmnopqrstuvwxyz"
alphabet = alphabet_upper  # This is assuming you're using uppercase letters for unused letters display

# Function to convert a lowercase character to uppercase
def char_to_upper(char):
    for i in range(len(alphabet_lower)):
        if char == alphabet_lower[i]:
            return alphabet_upper[i]
    return char

# Function to convert an entire string to uppercase
def input_to_upper(input_string):
    upper_string = ""
    for char in input_string:
        upper_string += char_to_upper(char)
    return upper_string

# Function to check if a letter is in a string
def is_letter_in_string(letter, string):
    for char in string:
        if char == letter:
            return True
    return False

def display_hangman_for_six_guesses(tries_left):
    # Determine the stage based on the number of tries left
    if tries_left == 6:
        # Initial figure for 6 guesses left (blank canvas)
        print("\n\n\n\n\n")
    elif tries_left == 5:
        # After the 1st incorrect guess
        print(" O\n\n\n\n")
    elif tries_left == 4:
        # After the 2nd incorrect guess
        print(" O\n |\n\n\n")
    elif tries_left == 3:
        # After the 3rd incorrect guess
        print(" O\n\|\n\n\n")
    elif tries_left == 2:
        # After the 4th incorrect guess
        print(" O\n\|/\n\n\n")
    elif tries_left == 1:
        # After the 5th incorrect guess
        print(" O\n\|/\n /\n\n")
    else:
        # Final figure after the 6th incorrect guess
        print(" O\n\|/\n / \\")

def display_hangman(tries_left):
    if tries_left == 1:
        # Initial figure for 1 guess left (before any guesses)
        print(" O\n\|/\n/ ")
    else:
        # Final figure when the guess is incorrect (0 guesses left)
        print(" O\n\|/\n/\\")

        
# Function to get the word choice from the user,
def get_word_choice():
    valid_responses = ["YES", "NO"]
    choice = input_to_upper(input("Would you like the program to choose a random word? (Yes/No): "))
    while not validate_choice(choice, valid_responses):
        print("Invalid choice. Please enter 'Yes' or 'No'.")
        choice = input_to_upper(input("Would you like the program to choose a random word? (Yes/No): "))
    
    if choice == "NO":
        word = input_to_upper(input("Enter the word to be guessed by your opponent: "))
        return word  # Directly return the word input by the user.
    else:
        difficulty = get_difficulty()
        filtered_words = filter_words_by_difficulty(WORDS, difficulty)  # Filter words based on difficulty
        if not filtered_words:  # Check if the filtered list is empty
            print("No words available for this difficulty. Please choose a different difficulty.")
            return get_word_choice()  # Recursively call itself to get a valid word choice
        random_index = int(random.random() * len(filtered_words))  # Calculate random index without using random.choice or randint
        return filtered_words[random_index]  # Return a word at the calculated random index

# Function to get the difficulty level from the user
def get_difficulty():
    difficulty = input_to_upper(input("Choose difficulty (easy/medium/hard/extreme): "))
    while difficulty != "EASY" and difficulty != "MEDIUM" and difficulty != "HARD" and difficulty != "EXTREME":
        print("Please choose a valid difficulty.")
        difficulty = input_to_upper(input("Choose difficulty (easy/medium/hard/extreme): "))
    return difficulty

def count_letters(word):
    letter_count = 0
    for char in word:
        if char != " ":  # Skip spaces
            letter_count += 1
    return letter_count

def filter_words_by_difficulty(words, difficulty):
    if difficulty == "EASY":
        return [word for word in words if len(word) <= 4]
    elif difficulty == "MEDIUM":
        return [word for word in words if 5 <= len(word) <= 6]
    elif difficulty == "HARD":
        # HARD: Long words without spaces
        return [word for word in words if len(word) > 9 and " " not in word]
    elif difficulty == "EXTREME":
        # EXTREME: Phrases or words with spaces
        return [word for word in words if " " in word]
    return []  # Return an empty list as a fallback

# Adjust get_word_choice to use filter_words_by_difficulty after getting difficulty

# Function to set the number of guesses allowed
def set_number_of_guesses():
    num_guesses = input("Please enter the number of guesses allowed: ")
    is_valid = True
    for char in num_guesses:
        if not ('0' <= char <= '9'):
            is_valid = False
            break
    if is_valid and num_guesses:
        return int(num_guesses)
    else:
        print("Invalid input. Defaulting to 6 guesses.")
        return 6

# Function to display the current status of the game
def display_status(word, guessed_letters, tries):
    print("\nGuess the word, " + str(tries) + " guess(es) left: ", end="")
    for letter in word:
        if letter == " " or is_letter_present(letter, guessed_letters):
            print(letter, end="")
        else:
            print("-", end="")
    print()  # For newline after the word

    # Display unused letters
    print("Unused letters: ", end="")
    for letter in alphabet_upper:
        if not is_letter_present(letter, guessed_letters):
            print(letter, end="")
    print()  # For newline after unused letters

def is_letter_present(letter, string):
    for char in string:
        if char == letter:
            return True
    return False

def input_to_upper(input_string):
    upper_string = ""
    lowercase_letters = list("abcdefghijklmnopqrstuvwxyz")
    uppercase_letters = list("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
    
    for char in input_string:
        if 'a' <= char <= 'z':
            index = 0
            while char != lowercase_letters[index]:
                index += 1
            upper_string += uppercase_letters[index]
        else:
            upper_string += char
    return upper_string


def validate_choice(choice, valid_options):
    for option in valid_options:
        if choice == option:
            return True
    return False

def get_word_choice():
    valid_responses = ["YES", "NO"]
    choice = input_to_upper(input("Would you like the program to choose a random word? (Yes/No): "))
    while not validate_choice(choice, valid_responses):
        print("Invalid choice. Please enter 'Yes' or 'No'.")
        choice = input_to_upper(input("Would you like the program to choose a random word? (Yes/No): "))

    if choice == "NO":
        word = input_to_upper(input("Enter the word to be guessed by your opponent: "))
        return word
    else:
        difficulty = get_difficulty()
        filtered_words = filter_words_by_difficulty(WORDS, difficulty)
        if not filtered_words:
            print("No words available for this difficulty. Please choose a different difficulty.")
            return get_word_choice()  # Recursively call to ensure a valid word is chosen
        random_index = int(random.random() * len(filtered_words))
        return filtered_words[random_index]

def play_game(word, max_tries):
    guessed_letters = ""
    tries_left = max_tries
    mistakes = 0
    hangman_stages = generate_hangman_stages(max_tries)

    while tries_left > 0:
        display_status(word, guessed_letters, tries_left)
        
        # Display hangman for the current stage
        # The number of stages is equal to max_tries; index is max_tries - tries_lef
        current_stage_index = max_tries - tries_left + 1  # Assuming mistakes start counting from 1
        display_hangman(max_tries, max_tries, hangman_stages)
        
        guess = char_to_upper(input("Your guess: "))
        
        # Validate guess: single character and a letter
        if len(guess) != 1 or not guess.isalpha():
            print("Invalid input. Please enter a single letter.")
            continue  # Skip the rest of the loop and prompt for input again
        
        already_guessed = is_letter_present(guess, guessed_letters)
        
        if not already_guessed:
            guessed_letters += guess
            if not is_letter_in_string(guess, word):
                tries_left -= 1
                mistakes += 1
                if mistakes == 3:
                    print("Hint: Try focusing on common vowels and consonants.")
                    mistakes = 0
            else:
                mistakes = 0  # Reset mistake count on a correct guess
        else:
            print("You have already used that letter.")
        
        # Check if all letters have been guessed
        all_guessed = True
        for letter in word:
            if letter != " " and not is_letter_present(letter, guessed_letters):
                all_guessed = False
                break
        
        if all_guessed:
            print("CONGRATULATIONS! YOU WIN!")
            return
    
    # When no tries left, display the final hangman stage
    display_hangman(hangman_stages[-1])  # Display the complete hangman figure
    print("SORRY YOU GOT HANGED! The word was:", word)

# Main function to start the game
def main():
    print("LET'S PLAY HANGMAN!\n")
    word = get_word_choice()
    max_tries = set_number_of_guesses()
    play_game(word, max_tries)

    play_again = input_to_upper(input("Play again with the same word? (Yes/No): "))
    while not validate_choice(play_again, ["YES", "NO"]):
        print("Please enter a valid option (Yes/No).")
        play_again = input_to_upper(input("Play again with the same word? (Yes/No): "))

    if play_again == "YES":
        main()
    elif play_again == "NO":
        start_new_game = input_to_upper(input("Start a new game? (Yes/No): "))
        while not validate_choice(start_new_game, ["YES", "NO"]):
            print("Please enter a valid option.")
            start_new_game = input_to_upper(input("Start a new game? (Yes/No): "))
            
        if start_new_game == "YES":
            main()
        elif start_new_game == "NO":
            return
        else:
            print("Invalid input. Exiting the game.")

# Entry point of the program
if __name__ == "__main__":
    main()
